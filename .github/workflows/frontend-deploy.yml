name: Frontend Build and Deploy

# Trigger the workflow on pushes to the specified branch
# Also allow manual triggering from the Actions tab
on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allows manual trigger from GitHub UI

# Define environment variables that can be used across all jobs
env:
  NODE_VERSION: '20'  # Use Node.js LTS version
  AWS_REGION: 'eu-north-1'  # Default AWS region, can be overridden by secrets

jobs:
  build-and-deploy:
    name: Build Frontend and Deploy to AWS
    runs-on: ubuntu-latest
    
    # Explicitly set minimal permissions for security
    permissions:
      contents: read  # Required to checkout the repository
    
    # Set working directory for all run steps in this job
    defaults:
      run:
        working-directory: ./frontend
    
    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Step 2: Setup Node.js environment
      # Uses the LTS version specified in env variables
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: './frontend/package-lock.json'
      
      # Step 3: Install dependencies
      # Using 'npm ci' for clean, reproducible builds (faster than 'npm install')
      - name: Install dependencies
        run: npm ci
      
      # Step 4: Prepare for static export build
      # Remove API routes (not supported with output: 'export') and build static site
      - name: Build frontend (static export)
        run: |
          # Remove API routes - they only work in standalone/server mode.
          # In static export, the frontend calls the backend directly via NEXT_PUBLIC_API_URL.
          rm -rf app/api

          # Build with static export mode
          npm run build
        env:
          NODE_ENV: production
          # Tell next.config.ts to use output: 'export'
          NEXT_OUTPUT_MODE: export
          # Set the backend URL so client-side API calls go directly to it
          NEXT_PUBLIC_API_URL: ${{ secrets.BACKEND_API_URL }}
      
      # Step 5: Create ZIP archive of static build artifacts
      # The 'out/' directory contains all static HTML, CSS, JS files ready for hosting
      - name: Create build archive
        run: |
          # Verify the static export output exists
          if [ ! -d "out" ]; then
            echo "ERROR: 'out' directory not found. Static export may have failed."
            exit 1
          fi

          echo "Static export contents:"
          ls -la out/
          echo ""
          echo "Locale directories:"
          ls -la out/it/ 2>/dev/null || echo "No /it directory"
          ls -la out/en/ 2>/dev/null || echo "No /en directory"

          # Generate timestamp for consistent file naming
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          echo "BUILD_TIMESTAMP=${TIMESTAMP}" >> $GITHUB_ENV

          # Create ZIP from the contents of out/ (files at root of ZIP = served at root of site)
          cd out
          zip -r ../../frontend-build-${TIMESTAMP}.zip .
          cp ../../frontend-build-${TIMESTAMP}.zip ../../frontend-build-latest.zip
          cd ..
      
      # Step 6: Configure AWS credentials
      # Uses GitHub Secrets for secure authentication with AWS
      # Required secrets: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || env.AWS_REGION }}
      
      # Step 7: Upload build artifacts to S3
      # Uploads both timestamped and 'latest' versions of the build
      # Required secret: S3_BUCKET_NAME
      - name: Upload to S3
        run: |
          # Upload timestamped version with metadata
          aws s3 cp ../frontend-build-${BUILD_TIMESTAMP}.zip \
            s3://${{ secrets.S3_BUCKET_NAME }}/builds/frontend-build-${BUILD_TIMESTAMP}.zip \
            --metadata "build-date=$(date -u +%Y-%m-%dT%H:%M:%SZ),commit-sha=${{ github.sha }}"
          
          # Upload 'latest' version with metadata and cache control
          aws s3 cp ../frontend-build-latest.zip \
            s3://${{ secrets.S3_BUCKET_NAME }}/builds/frontend-build-latest.zip \
            --metadata "build-date=$(date -u +%Y-%m-%dT%H:%M:%SZ),commit-sha=${{ github.sha }}" \
            --cache-control "no-cache"
      
      # Step 8: Deploy to Amplify via CreateDeployment + StartDeployment
      # This method works for Amplify apps NOT connected to a repository provider.
      # Required secrets: AMPLIFY_APP_ID, AMPLIFY_BRANCH_NAME (optional, defaults to 'main')
      - name: Deploy to Amplify
        run: |
          if [ -n "${{ secrets.AMPLIFY_APP_ID }}" ]; then
            BRANCH_NAME="${{ secrets.AMPLIFY_BRANCH_NAME }}"
            BRANCH_NAME="${BRANCH_NAME:-main}"
            echo "Creating Amplify deployment for app: ${{ secrets.AMPLIFY_APP_ID }}, branch: ${BRANCH_NAME}"

            # Step 8a: Create a deployment to get a pre-signed upload URL
            DEPLOYMENT=$(aws amplify create-deployment \
              --app-id ${{ secrets.AMPLIFY_APP_ID }} \
              --branch-name "${BRANCH_NAME}" \
              --output json)

            UPLOAD_URL=$(echo "$DEPLOYMENT" | jq -r '.zipUploadUrl')
            JOB_ID=$(echo "$DEPLOYMENT" | jq -r '.jobId')

            echo "Got deployment job ID: ${JOB_ID}"

            # Step 8b: Upload the build zip to the pre-signed URL
            echo "Uploading build artifact to Amplify..."
            curl --fail --silent --show-error \
              -T ../frontend-build-latest.zip \
              "${UPLOAD_URL}"

            echo "Upload complete."

            # Step 8c: Start the deployment with the uploaded artifact
            aws amplify start-deployment \
              --app-id ${{ secrets.AMPLIFY_APP_ID }} \
              --branch-name "${BRANCH_NAME}" \
              --job-id "${JOB_ID}"

            echo "Amplify deployment started successfully (job: ${JOB_ID})"
            echo "AMPLIFY_TRIGGERED=api" >> $GITHUB_ENV
          elif [ -n "${{ secrets.AMPLIFY_WEBHOOK_URL }}" ]; then
            echo "Triggering Amplify via webhook"
            curl -X POST "${{ secrets.AMPLIFY_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d "{\"source\":\"github-actions\",\"commit\":\"${{ github.sha }}\"}"
            echo "Amplify deployment triggered successfully via webhook"
            echo "AMPLIFY_TRIGGERED=webhook" >> $GITHUB_ENV
          else
            echo "AMPLIFY_APP_ID and AMPLIFY_WEBHOOK_URL not set, skipping Amplify deployment"
            echo "AMPLIFY_TRIGGERED=none" >> $GITHUB_ENV
          fi
      
      # Step 9: Output deployment information
      - name: Deployment summary
        run: |
          echo "âœ… Frontend build completed successfully"
          echo "ðŸ“¦ Build archive uploaded to S3"
          
          # Conditionally report Amplify deployment status
          if [ "$AMPLIFY_TRIGGERED" = "api" ]; then
            echo "ðŸš€ Amplify deployment triggered via API (app: ${{ secrets.AMPLIFY_APP_ID }})"
          elif [ "$AMPLIFY_TRIGGERED" = "webhook" ]; then
            echo "ðŸš€ Amplify deployment triggered via webhook"
          else
            echo "ðŸš« Amplify deployment was not triggered (no AMPLIFY_APP_ID or webhook configured)"
          fi
          
          echo ""
          echo "Build details:"
          echo "  - Commit: ${{ github.sha }}"
          echo "  - Branch: ${{ github.ref_name }}"
          echo "  - S3 Bucket: ${{ secrets.S3_BUCKET_NAME }}"
          echo "  - Build file: frontend-build-latest.zip"